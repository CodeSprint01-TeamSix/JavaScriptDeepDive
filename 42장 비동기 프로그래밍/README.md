## 😀 동기 처리와 비동기 처리

### ❤️ 실행 컨텍스트 스택

```js
function firstFunc() {
  console.log("firstFunc() Call!");
  secondFunc();
}

function secondFunc() {
  console.log("secondFunc() Call!");
}

firstFunc();
```

![](https://velog.velcdn.com/images/asj1966/post/560aecb5-9130-4bbd-a8a0-ec3004eb1796/image.png)
-> 함수 "호출"시, 함수 코드가 평가 되어 **함수 실행 컨텍스트** 생성
-> 함수 실행 컨텍스트는 **실행 컨텍스트 스택(콜 스택)** 에 푸시
-> 함수 실행
-> 함수 코드 종료 시, 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 제거

### ❤️ 동기 처리

: 자바스크립트 엔진은 한 번에 하나의 태스크만을 실행할 수 있는 '싱글 스레드'

### 즉,

#### 함수가 실행되려면 함수 코드 평가 과정에서 생성된 '함수 실행 컨텍스트'가 실행 컨텍스트 스택에 푸쉬되어야 함 (함수 실행의 시작을 의미)

- 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다
  -> 함수를 실행할 수 있는 창구가 단 하나!
  -> 대기 중인 태스크들은 현재 실행 중인 함수가 실행 컨텍스트에서 팝 되어야 (함수 종료) 비로소 실행

###

-> 처리에 시간이 걸리는 태스크를 실행하는 경우에는 블로킹(작업 중단) 발생 (ex-setTimeout)

#### 🌍 장단점

- 장점: 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장
- 단점: 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹

### ❤️ 비동기 처리

: 현재 실행중인 태스크가 **종료되지 않은 상태**라 해도 다음 태스크를 곧바로 실행하는 방식

#### 🌍 장단점

- 장점: 블로킹이 발생하지 않음
- 단점: 태스크의 실행 순서가 보장되지 않음

-> 비동기 함수들은 보통 '**콜백 패턴**'을 사용

#### 🌍 비동기 처리 방식 동작 예시

- setTimeout
- setInterval
- HTTP 요청
- 이벤트 핸들러

-> 비동기 처리는 이벤트 루프와 태스크 큐와 연관성이 깊다

## 😀 이벤트 루프와 태스크 큐

: 자바스크립트는 '싱글 스레드'로 동작하지만, 여러 태스크가 동시에 처리되는 것처럼 느껴짐
-> **'이벤트 루프'** 는 자바스크립트의 '동시성' 지원

### ❤️ 자바스크립트 엔진의 2가지 영역

#### 1. 콜 스택

: 소스코드 평가 과정에서 생성된 실행 컨텍스트 추가되고 제거되는 스택 자료구조
-> 함수 **호출** 시, 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행

#### 2. 힙

: 객체가 저장되는 메모리 공간
-> 콜 스택의 실행 컨텍스트는 힙에 저장된 객체 참조
-> 구조화 되어있지 않다
왜?
객체는 원시값과 달리 크기가 정해져 있지 않아서, 할당해야 할 메모리 공간의 크기를 **런타임에 결정(동적 할당)**

-> 비동기 처리에서 소소코드 평가와 실행을 제외한 모든 처리는 **자바스크립트 엔진을 구동하는 환경인 브라우저나 Node.js가 담당**
-> 이를 위해 브라우저는 태스크 큐와 이벤트 루프 제공

### ❤️ 태스크 큐

: setTimeout이나 setInterval과 같은 비동기 함수의 **콜백 함수나 이벤트 핸들러가 일시적으로 보관되는 영역**

### ❤️ 이벤트 루프

: 브라우저 내장 기능으로
![](https://velog.velcdn.com/images/asj1966/post/72bab843-c4fc-4f82-adb2-254a0880a8ee/image.png)
: 콜 스택에 **현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인**
-> **콜 스택 비어있고, 태스크 큐에 대기 중인 함수가 있다면, 이벤트 루프는 FIFO 방식으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동**

### ❤️ 태스크 큐와 이벤트 루프를 이용한 비동기 처리 과정

#### ! 비동기 함수의 콜백함수는 태스크 큐에서 대기하다가 콜 스택이 비게 되면, 그제서야 콜 스택에 푸시되어 실행!

#### 브라우저와 자바스크립트 엔진이 협력하여 비동기 처리!

: 브라우저는 멀티 스레드, 자바스크립트 엔진이 싱글스레드!!

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 0);
bar();
```

1. 전역 코드가 평가되어 전역 실행 컨텍스트 생성하여 콜 스택에 푸시되어 현재 실행 중인 컨텍스트가 되며
2. 전역 코드들 수행하여, setTimeout함수 호출되어 함수 실행 컨텍스트 생성되고 콜 스택에 푸시되고, 현재 실행 중인 컨텍스트
3. **브라우저**: 타이머 설정과 만료, **타이머 만료 시**, 콜백 함수를 태스크 큐에 등록/ **자바스크립트 엔진**: bar()함수 호출되어 함수 실행 컨텍스트 생성하고 콜 스택에 푸시되고, 종료 시 팝-> **2가지 병렬적으로 일어남**
   -> 정확히 지연 시간 후에 호출된다는 보장이 없다: 타이머 만료 이후, 태스크 큐에 등록되자마자 콜 스택에서 호출되어 실행된다는 보장이 없기 때문 (콜 스택 비어있지 않을 수도)
4. 전역 코드 실행이 종료되며, 전역 컨텍스트까지 팝. 콜 스택에는 아무런 실행 컨텍스트 존재하지 않음
5. **이벤트 루프**에 의해서 콜 스택이 비어있고, 태스크 큐에 대기 중인 콜백 함수 foo가 함수 실행 컨텍스트 생성하고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 된다. 함수 종료되어, 콜 스택에서 팝

### ⭕ 정리

- 자바스크립트 엔진에는 1개의 콜 스택만 존재하므로 싱글 스레드 (동기적으로 처리)
- 함수 **호출**!! 시, 실행 컨텍스트 스택에 푸시 (선언 시 아님!)
- 싱글 스레드의 단점: 블로킹 현상
- 비동기 처리: 자바스크립트 엔진은 싱글 스레드, 브라우저는 멀티 스레드의 협력
- 자바스크립트 엔진은 평가와 실행 위주로! (콜 스택에 푸시-실행, 팝-종료)
- 자바스크립트 엔진은 콜 스택과 힙으로 구성
- 비동기 처리의 평가와 실행을 제외한 것 (ex-타이머, 타이머 만료 시, 태스크 큐에 등록)은 브라우저에서 실행: 비동기 처리를 할 수 있게되는 원리
- 비동기 처리를 위해 이벤트 루프와 큐 존재
- 타이머 만료 시, 태스크 큐에 등록

<비동기 처리 과정>
함수 호출 시, 실행 컨텍스트를 콜 스택에 저장한다. 만약 비동기 함수인 경우(setTimeout) 브라우저에서 타이머와 관련된 작업들 처리하게 넘긴다. 그리고 그 동시에 다음 함수를 실행해서 콜 스택에 넣고 팝하는 과정을 반복한다. 브라우저에서는 타이머 경과 시, 준비되었으므로 태스크 큐에 넣어놓고 대기한다. 그리고, 콜 스택의 전역 콘텍스트까지 팝 되어 모든 작업이 완료 되었음 이벤트 루프가 감지를 하고, 그제서야 태스크 큐에 있는 콜백함수를 콜 스택으로 호출하여 수행한다. 그 과정에서 브라우저에서 제공하는 webAPI도 함께 사용될 수 있다. **즉, 전역 콘텍스트까지 팝 된 이후로, 태스크 큐에 있는 작업 호출해서 가져온다는 것!!!!**
